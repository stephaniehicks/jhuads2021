[
  {
    "path": "posts/2021-11-10-linear-classification/",
    "title": "Linear Classification",
    "description": "Introduction to linear classification methods.",
    "author": [
      {
        "name": "Stephanie Hicks",
        "url": "https://stephaniehicks.com/"
      }
    ],
    "date": "2021-11-07",
    "categories": [
      "machine learning",
      "linear classification"
    ],
    "contents": "\n\nContents\nPre-lecture materials\nAcknowledgements\n\nLearning objectives\nMotivation\nThree widely used linear classifiers\n\nData\nData import\nWhat are the features?\nWhat are the outcomes?\nHow does this related to machine learning?\nCalculating the top PCs\n\n\nData wrangling\nFeature engineering\nExploratory data analysis\nCreate train_set and test_set\n\nLinear methods for classification\nLinear regression\nLogistic regression\nLinear discriminant analysis\n\\(K\\)-nearest neighbors\n\n\nPre-lecture materials\nAcknowledgements\nMaterial for this lecture was borrowed and adopted from\nAn Introduction to Statistical Learning, 2013 by James, Witten, Hastie and Tibshirani\nThe dsbook from Rafael Irizarry\nhttps://en.wikipedia.org/wiki/Linear_discriminant_analysis\nLearning objectives\n\nAt the end of this lesson you will:\nKnow how to implement three linear classifiers: (i) linear and logistic regression, (ii) linear and quadratic discriminant analysis, and (iii) \\(K\\)-nearest neighbors\n\nMotivation\nIn the previous lectures, we have learned about machine learning algorithms, where decisions made are based on algorithms built on data. The data we have often comes in the form of an outcome we want to predict and the features that we will use to predict the outcome. This setting is often called a supervised learning (as opposed to the unsupervised learning setting without an outcome variable, such as clustering or dimensionality reduction).\n\nThe general idea of supervised learning is that we build the algorithm using the data that includes the outcome so that in the future we can predict the outcome only using the features. Here we will use \\(Y\\) to denote the outcome and \\(X_1, \\dots, X_p\\) to denote features.\nNote: the features are sometimes referred to as predictors or covariates and the outcome is sometimes referred to as a response variable.\n\nIf the outcome \\(Y\\) is quantitative, something like linear regression is very useful for predicting a quantitative response. But in many situations, the responsible variable is qualitative (or categorical).\nPredicting a qualitative response \\(Y\\) is referred to as classification since it involves assigning each observation to a category or class.\nSo the general set-up is as follows. Given a set of predictors \\(X_{ij}\\) and and qualitative outcome \\(Y_i\\), we can collect data to classify or predict which class or category each outcome (or observation) belongs in:\n\noutcome\nfeature_1\nfeature_2\nfeature_3\nfeature_4\nfeature_5\nY_1\nX_1,1\nX_1,2\nX_1,3\nX_1,4\nX_1,5\nY_2\nX_2,1\nX_2,2\nX_2,3\nX_2,4\nX_2,5\nY_3\nX_3,1\nX_3,2\nX_3,3\nX_3,4\nX_3,5\nY_4\nX_4,1\nX_4,2\nX_4,3\nX_4,4\nX_4,5\nY_5\nX_5,1\nX_5,2\nX_5,3\nX_5,4\nX_5,5\nY_6\nX_6,1\nX_6,2\nX_6,3\nX_6,4\nX_6,5\nY_7\nX_7,1\nX_7,2\nX_7,3\nX_7,4\nX_7,5\nY_8\nX_8,1\nX_8,2\nX_8,3\nX_8,4\nX_8,5\nY_9\nX_9,1\nX_9,2\nX_9,3\nX_9,4\nX_9,5\nY_10\nX_10,1\nX_10,2\nX_10,3\nX_10,4\nX_10,5\n\nThree widely used linear classifiers\nToday, we will focus on the three of the most widely used classifiers:\nLinear and Logistic regression\nLinear and Quadratic discriminant analysis\n\\(K\\)-nearest neighbors\nYou have already learned about other methods including, trees, random forests, and boosting. Next week, we will cover support vector machines.\nData\nFor this lecture, we will use the Fashion-MNIST dataset from Kaggle.\nThe motivating question is:\nCan we build a classier to accurately classify images of pieces of clothing?\nThe data consists of a training set of 60,000 images and a test set of 10,000 examples. We will assume the test set is the only data available for the purposes of this lecture (mostly because it is 1/6 of the size of the training set!).\nFor example, we want to build a classifier to recognize this image as a pair of pants:\n\n\n\nAnd the classifier should be able to recognize this image as shoe:\n\n\n\nThe fashion MNIST dataset contains a set of images of clothing or fashion pieces. Each observation \\(Y_i\\) is labeled one of the following:\n0 = T-shirt/top\n1 = Trouser\n2 = Pullover\n3 = Dress\n4 = Coat\n5 = Sandal\n6 = Shirt\n7 = Sneaker\n8 = Bag\n9 = Ankle boot\nThe are images are converted into \\(28 \\times 28\\) pixels and for each we obtain an gray scale intensity between 0 (white) to 256 (black).\nWe will explore this data set using some common machine learning algorithms for classification.\nData import\nFirst, we load a few R packages\n\n\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(caret)\nlibrary(pROC)\nlibrary(here)\n\n\n\nThe data are available in the /data folder of this repository.\nFirst, let’s read in the fashion-mnist_test.csv dataset using the read_csv() function in the readr package.\n\n\nif(!exists(\"fashion\")) { \n  fashion <- read_csv(here(\"data\", \"fashion-mnist_test.csv\"))\n}\n\n\n\nHere we save just pixels\n\n\nX <- \n  fashion %>% \n  select(-label) %>% \n  as.matrix()\ndim(X)\n\n\n[1] 10000   784\n\nAnd we also save the labels (i.e. 0-9)\n\n\nfashion_labels <- \n  fashion %>% \n  pull(label)\nfashion_labels[1:5]\n\n\n[1] 0 1 2 2 3\n\nWe can look at the first three images to see what they look like.\n\n\ntmp <- lapply(c(1:3), function(i){\n    expand.grid(Row=1:28, Column=1:28) %>%  \n      mutate(id=i, label=fashion$label[i],  \n             value = unlist(fashion[i,-1])) })\ntmp <- Reduce(rbind, tmp)\ntmp %>% ggplot(aes(Row, Column, fill=value)) + \n    geom_raster() + \n    scale_y_reverse() +\n    scale_fill_gradient(low=\"white\", high=\"black\") +\n    facet_grid(.~label)\n\n\n\n\nWhat are the features?\nEach image is converted into \\(28 \\times 28\\) pixels and for each we obtain an grey scale intensity between 0 (white) to 255 (black).\nThis means one image has 784 (=28*28) features.\nWe can see these values like this:\n\n\ntmp %>% ggplot(aes(Row, Column, fill=value)) + \n    geom_point(pch=21,cex=2) + \n    scale_y_reverse() +\n    scale_fill_gradient(low=\"white\", high=\"black\") +\n    facet_grid(.~label)\n\n\n\n\nWe use bold face to denote this vector of predictors\n\\[ \\mathbf{X}_i = (X_{i,1}, \\dots, X_{i,784}) \\]\nLet’s take a peek at \\(\\mathbf{X}\\):\n\n\nX[1:10, 1:10]\n\n\n      pixel1 pixel2 pixel3 pixel4 pixel5 pixel6 pixel7 pixel8 pixel9\n [1,]      0      0      0      0      0      0      0      9      8\n [2,]      0      0      0      0      0      0      0      0      0\n [3,]      0      0      0      0      0      0     14     53     99\n [4,]      0      0      0      0      0      0      0      0      0\n [5,]      0      0      0      0      0      0      0      0      0\n [6,]      0      0      0      0      0     44    105     44     10\n [7,]      0      0      0      0      0      0      0      0      0\n [8,]      0      0      0      0      0      0      0      1      0\n [9,]      0      0      0      0      0      0      0      0      0\n[10,]      0      0      0      0      0      0      0      0      0\n      pixel10\n [1,]       0\n [2,]       0\n [3,]      17\n [4,]     161\n [5,]       0\n [6,]       0\n [7,]       0\n [8,]       0\n [9,]       0\n[10,]       0\n\nWhat are the outcomes?\nEven though the label here is a whole number between 0 and 9, this is a qualitative outcome (e.g. shirt, pants, shoes, etc).\n\n\nfashion_labels[1:7]\n\n\n[1] 0 1 2 2 3 2 8\n\nSo for each image \\(i\\) we have an outcome \\(Y_i\\) which can be one of 10 categories: \\(0,1,2,3,4,5,6,7,8,9\\) and the features \\(X_{i,1}, \\dots, X_{i,784}\\) which can take values from 0 to 255.\nHow does this related to machine learning?\nThe machine learning task here is to build a predictor function, \\(f\\) that converts \\(\\mathbf{X}\\) into a prediction category \\(\\hat{Y}_i = f(\\mathbf{X}_i)\\) that minimizes the \\(d(Y,\\hat{Y})\\)\nCalculating the top PCs\nIf you recall, the first PC is will explain the most variation, the second PC will explain the second most variation in the data, etc.\nBecause the pixels are so small we expect those to be close to each other on the grid to be correlated, meaning that dimension reduction should be possible.\nLet’s take the singular value decomposition (SVD) of \\(\\mathbf{X}\\).\n\n\ndim(X) #  10000 observation, 784 features\n\n\n[1] 10000   784\n\nRemember, we need to column center the data (using scale()). We also will create a new variable \\(\\mathbf{Y}\\) to represent the standardized data that is also transposed (features along rows).\n\n\nY <- t(scale(X,center=TRUE, scale=FALSE)) \ndim(Y)\n\n\n[1]   784 10000\n\nNow apply the svd() function to \\(\\mathbf{Y}\\).\n\n\ns <- svd(Y)\nstr(s)\n\n\nList of 3\n $ d: num [1:784] 113672 89269 51516 47079 41325 ...\n $ u: num [1:784, 1:784] -7.63e-08 -1.01e-05 -4.32e-05 -5.51e-05 -1.87e-04 ...\n $ v: num [1:10000, 1:784] -0.012246 0.000349 0.007291 -0.006896 -0.00233 ...\n\nFirst note that we can in fact reconstruct \\(\\mathbf{Y}\\) using all the PCs:\n\n\nYhat <- s$u %*% diag(s$d) %*% t(s$v)\nresid <- Y - Yhat\nmax(abs(resid))\n\n\n[1] 6.843166e-10\n\nIf we look at the eigenvalues in \\(\\mathbf{D}\\), we see that the last few are quite close to 0.\n\n\nplot(s$d)\n\n\n\n\nThis implies that the last columns of \\(\\mathbf{V}\\) (right singular vectors) have a very small effect on the reconstruction of \\(\\mathbf{X}\\).\nTo see this, consider the extreme example in which the last entry of \\(\\mathbf{V}\\) is 0. In this case, the last column of \\(\\mathbf{V}\\) is not needed at all.\nBecause of the way the SVD is created, the columns of \\(\\mathbf{V}\\), have less and less influence on the reconstruction of \\(\\mathbf{X}\\). You commonly see this described as “explaining less variance”. This implies that for a large matrix, by the time you get to the last columns, it is possible that there is not much left to “explain”.\nAs an example, we will look at what happens if we remove the 100 last columns:\n\n\nk <- ncol(s$v)-100\nYhat <- s$u[,1:k] %*% diag(s$d)[1:k,1:k] %*% t(s$v[,1:k])\nresid <- Y - Yhat \nmax(abs(resid))\n\n\n[1] 182.8126\n\nThe largest residual is practically 0, meaning that Yhat is practically the same as Y, yet we need 100 less dimensions to transmit the information.\nBy looking at \\(\\mathbf{D}\\), we can see that, in this particular dataset, we can obtain a good approximation keeping only a subset of columns. The following plots are useful for seeing how much of the variability is explained by each column:\n\n\nplot(s$d^2/sum(s$d^2)*100,\n     ylab=\"Percent variability explained\")\n\n\n\n\nWe can also make a cumulative plot:\n\n\nplot(cumsum(s$d^2)/sum(s$d^2)*100,\n     ylab=\"Percent variability explained\",\n     ylim=c(0,100), type=\"l\")\n\n\n\n\nAlthough we start with 784 dimensions, we can approximate \\(X\\) with just a few:\n\n\nk <- 100 ## out a possible 784\nYhat <- s$u[,1:k] %*% diag(s$d)[1:k,1:k] %*% t(s$v[,1:k])\nresid <- Y - Yhat\n\n\n\nTherefore, by using only 100 dimensions, we retain most of the variability in our data:\n\n\n1 - var(as.vector(resid))/var(as.vector(Y))\n\n\n[1] 0.9140806\n\nWe say that we explain 91 percent of the variability in our data with 100 PCs.\nNote that we can compute this proportion from \\(\\mathbf{D}\\):\n\n\nsum(s$d[1:k]^2)/sum(s$d^2)\n\n\n[1] 0.9140806\n\nThe entries of \\(\\mathbf{D}\\) therefore tell us how much each PC contributes in term of variability explained.\nAnother way of calculating the PCs is to use prcomp() function.\n\n\npc <- prcomp(X, center=TRUE)\n\n\n\nThe proportion of variance of the first ten PCs is quite high (almost 75%):\n\n\nsummary(pc)$importance[,1:10]\n\n\n                              PC1       PC2       PC3       PC4\nStandard deviation     1136.77538 892.73736 515.18167 470.80915\nProportion of Variance    0.29028   0.17903   0.05962   0.04979\nCumulative Proportion     0.29028   0.46931   0.52893   0.57872\n                             PC5       PC6       PC7       PC8\nStandard deviation     413.27284 391.59029 323.28114 287.81159\nProportion of Variance   0.03837   0.03445   0.02348   0.01861\nCumulative Proportion    0.61708   0.65153   0.67501   0.69361\n                             PC9      PC10\nStandard deviation     246.78152 242.84965\nProportion of Variance   0.01368   0.01325\nCumulative Proportion    0.70729   0.72054\n\nWe can also plot the standard deviations:\n\n\nplot(pc$sdev)\n\n\n\n\nor the more common plot variance explained:\n\n\nplot(pc$sdev^2 / sum(pc$sdev^2))\n\n\n\n\nWe can also see that the first two PCs will in fact be quite informative. Here is a plot of the first two PCs, but colored by the labels that we ignored:\n\n\ndata.frame(PC1 = pc$x[,1], PC2 = pc$x[,2],\n           label=factor(fashion_labels)) %>%\n  ggplot(aes(PC1, PC2, fill=label))+\n  geom_point(cex=3, pch=21)\n\n\n\n\nWe can also “see” the linear combinations on the grid to get an idea of what is getting weighted:\n\n\ntmp <- lapply( c(1:4,781:784), function(i){\n    expand.grid(Row=1:28, Column=1:28) %>%\n      mutate(id=i, label=paste0(\"PC\",i), \n             value = pc$rotation[,i])\n})\ntmp <- Reduce(rbind, tmp)\n\ntmp %>% filter(id<5) %>%\n  ggplot(aes(Row, Column, fill=value)) +\n  geom_raster() +\n  scale_y_reverse() +\n  facet_wrap(~label, nrow = 1)\n\n\n\n\n\n\ntmp %>% filter(id>5) %>%\n  ggplot(aes(Row, Column, fill=value)) +\n  geom_raster() +\n  scale_y_reverse() +\n  facet_wrap(~label, nrow = 1)\n\n\n\n\nData wrangling\nFor purposes of this lecture, we will focus only the 0s (tshirt/top) and 5s (sandals) observations:\n\n\ndat05 <- fashion %>% \n  filter(fashion_labels %in% c(0,5))\n\n## labels are not numbers\ndat05 <- mutate(dat05, label = as.factor(label))\n\n\n\nFeature engineering\nTo distinguish 0s (shirts) from 5s (sandals), it might be enough to look at the number of non-white pixels in the upper-left and lower-right quadrants:\n\n\n\nSo we will define two features \\(X_1\\) and \\(X_2\\) as the percent of non-white pixels in these two quadrants, respectively. We add these two features to the dat05 table\n\n\nrow_column <- expand.grid(row=1:28, col=1:28)\nhead(row_column)\n\n\n  row col\n1   1   1\n2   2   1\n3   3   1\n4   4   1\n5   5   1\n6   6   1\n\n\n\nind1 <- which(row_column$col <= 14 & row_column$row <=14) # top left quandrant\nind2 <- which(row_column$col > 14 & row_column$row > 14) # bottom right quadrant\nind <- c(ind1,ind2)\nX <- as.matrix(dat05[,-1]) # remove label column\nX <- X>200\nX1 <- rowSums(X[,ind1])/rowSums(X)\nX2 <- rowSums(X[,ind2])/rowSums(X)\ndat05 <- mutate(dat05, X_1 = X1, X_2 = X2, \n                y = ifelse(label==\"0\", 0, 1))\n\ndat05 %>% \n  select(label, y, X_1, X_2)\n\n\n# A tibble: 2,000 × 4\n   label     y   X_1   X_2\n   <fct> <dbl> <dbl> <dbl>\n 1 0         0 0.255 0.272\n 2 5         1 0     0.344\n 3 0         0 0.444 0    \n 4 5         1 0     0.409\n 5 5         1 0.153 0.203\n 6 5         1 0     0.362\n 7 0         0 0.364 0.455\n 8 0         0 0.377 0.148\n 9 0         0 0.280 0.244\n10 0         0 0.231 0.263\n# … with 1,990 more rows\n\nExploratory data analysis\nLet’s explore the relationship between the predictors (or features) \\(X_1\\) and \\(X_2\\) and the outcome \\(Y\\):\n\n\ndat05 %>% \n  select(label, X_1, X_2) %>% \n  ggplot(aes(x=label, y=X_1)) + \n  geom_boxplot()\n\n\n\n\nWe see a pronounced relationship between the the predictor \\(X_1\\) and the label (e.g. the \\(X_1\\) feature is high for the t-shirts and low for the sandals, which make sense).\n\n\ndat05 %>% \n  select(label, X_1, X_2) %>% \n  ggplot(aes(x=label, y=X_2)) + \n  geom_boxplot()\n\n\n\n\nIn this case, we again see a difference in the distribution of \\(X_2\\) across the t-shirts and sandals, but less so. This is still likely to be informative.\nFurthermore, we can also plot the relationship between \\(X_1\\) and \\(X_2\\) and see that there is separation between the 0s (t-shirts)and5`s (sandals):\n\n\ndat05 %>% \n  select(label, X_1, X_2) %>% \n  ggplot(aes(x=X_1, y=X_2, color = label)) + \n  geom_point()\n\n\n\n\nCreate train_set and test_set\nIn this last step of data wrangling, we will split the dat05 dataset into two parts:\ntrain_set = the dataset we will use to build the classifer\ntest_set = the dataset we will use to assess how we are doing (not used to train the classifier)\nFor this, we will use the createDataPartition() function in the caret package. We set the seed, so we will all get the same answer\n\n\nset.seed(123)\ninTrain <- createDataPartition(y = dat05$label,\n                               p=0.5)\ntrain_set <- slice(dat05, inTrain$Resample1)\ntest_set <- slice(dat05, -inTrain$Resample1)\n\n\n\nLinear methods for classification\nLinear regression\nOne approach would be to just try using simple linear regression.\nThis assumes that:\n\\[f(x) = \\mbox{Pr}( Y = 1 | X_1=x_1, X_2 = x_2)  = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\\]\nand we estimate \\(\\beta_0\\), \\(\\beta_1\\), \\(\\beta_2\\) with least squares. Once we have estimates \\(\\hat{\\beta}_0\\), \\(\\hat{\\beta}_1\\), and \\(\\beta_2\\) we can obtain an actual prediction rule:\n\\[ \\hat{f}(x) = \\hat{\\beta}_0+ \\hat{\\beta}_1 x_1 + \\hat{\\beta}_2 x_2 \\]\nThe problem with using linear regression is that to predict \\(Y\\) on the basis of predictors \\(\\mathbf{X}_i\\), we will need to order the outcomes.\nDoes it make sense here? Not quite. Why?\nIf \\(Y\\) is not quantiative (e.g. ten types of fashion pieces), it doesn’t quite make sense to put a “t-shirt” ahead of a “sandal” or behind a “pants”. This is because to use linear regression, we have to decide on an ordering and if we picked a different ordering, then that coding would produce a fundamentally different linear model with a different set of predictions on the test observations.\nHowever, if the response variable’s values did take on a natural ordering, such as mild, moderate, and severe, and we felt the gap between mild and moderate was similar to the gap between moderate and severe, then a 1, 2, 3 coding would be reasonable.\nUnfortunately, in general there is no natural way to convert a qualitative response variable with more than two levels into a quantitative response that is ready for linear regression.\nLogistic regression\nIf the qualitative response is binary (0 and 1), then one approach is to fit a linear regression to this binary response and predict 1 if the predicted response (\\(\\hat{Y}\\)) is \\(\\hat{Y} > 0.5\\) or 0 otherwise.\nSo if we consider our linear regression model above:\n\\[f(x) = \\mbox{Pr}( Y = 1 | X_1=x_1, X_2 = x_2)  = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\\]\nWe note that the expression on the right can be any real number while the expression on the left is bounded between 0 and 1.\nAn extension that permits us to continue using regression-like models is to apply transformations that eliminate this disconnect. In the case of binary data the most common approach is to fit a logistic regression model which makes use of the logit transformation:\n\\[ g(p) = \\log \\frac{p}{1-p}\\] and use this model instead:\n\\[ g(\\mbox{Pr}(Y=1 \\mid X_1=x_1 , X_2 = x_2) = \n\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\\]\nWe can fit a logistic regression model using the glm() function with the family=\"binomial\" argument.\n\n\nfit_glm <- glm(y ~ X_1 + X_2, \n               data = select(train_set, y, X_1, X_2), \n               family = \"binomial\")\nsummary(fit_glm)\n\n\n\nCall:\nglm(formula = y ~ X_1 + X_2, family = \"binomial\", data = select(train_set, \n    y, X_1, X_2))\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-2.7497  -0.4524   0.1068   0.4794   5.3194  \n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)   1.5549     0.2484   6.260 3.85e-10 ***\nX_1         -15.7030     0.9852 -15.940  < 2e-16 ***\nX_2           2.2024     0.6185   3.561  0.00037 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 1386.29  on 999  degrees of freedom\nResidual deviance:  656.62  on 997  degrees of freedom\nAIC: 662.62\n\nNumber of Fisher Scoring iterations: 6\n\nWe see both the \\(X_1\\) and \\(X_2\\) features are statisticially significant at the \\(\\alpha = 0.05\\) level.\nNext, if we predict or classify how each observation \\(Y_i\\) is doing using the predict()\n\n\npred_glm <- predict(fit_glm, newdata = test_set, type=\"response\")\ny_hat_glm <- factor(ifelse(pred_glm > 0.5, 1, 0))\ntab <- table(pred=y_hat_glm, truth= test_set$y)\nconf_matrix <- confusionMatrix(tab)\nconf_matrix\n\n\nConfusion Matrix and Statistics\n\n    truth\npred   0   1\n   0 447  51\n   1  53 449\n                                          \n               Accuracy : 0.896           \n                 95% CI : (0.8754, 0.9142)\n    No Information Rate : 0.5             \n    P-Value [Acc > NIR] : <2e-16          \n                                          \n                  Kappa : 0.792           \n                                          \n Mcnemar's Test P-Value : 0.9219          \n                                          \n            Sensitivity : 0.8940          \n            Specificity : 0.8980          \n         Pos Pred Value : 0.8976          \n         Neg Pred Value : 0.8944          \n             Prevalence : 0.5000          \n         Detection Rate : 0.4470          \n   Detection Prevalence : 0.4980          \n      Balanced Accuracy : 0.8960          \n                                          \n       'Positive' Class : 0               \n                                          \n\nThe confusion table can be extracted using the $table slot\n\n\nconf_matrix$table\n\n\n    truth\npred   0   1\n   0 447  51\n   1  53 449\n\nAnd the various performance metrics too:\n\n\nconf_matrix$overall[\"Accuracy\"]\n\n\nAccuracy \n   0.896 \n\nWe can also use the roc() function in the pROC package to plot the ROC curve comparing the sensitivity and specificity\n\n\nroc_glm <- roc(test_set$y, pred_glm)\nplot(roc_glm)\n\n\n\n\n\nLogistic regression for more than 2 response classes\nIn our example, we only considered the t-shirts and sandals, but we technically have more than two classes.\nIf the goal is to classify a response variable or outcome with more than two classes, there are multiple-class extensions.\nHowever, in practice they tend not to be used all that often. One of the reasons is that the method we discuss in the next section, discriminant analysis, is popular for multiple-class classification. So we do not go into the details of multiple-class logistic regression here, but simply note that such an approach is possible, and that software for it is available in R.\n\nLinear discriminant analysis\nLogistic regression involves directly modeling \\(Pr(Y = k|X = x)\\) using the logistic function, for the case of two response classes.\nAn alternative and less direct approach to estimate these probabilities is to model the distribution of the predictors \\(X\\) separately in each of the response classes (i.e. given \\(Y\\)) or \\(Pr(X = x|Y = k)\\), and then use Bayes’ theorem to flip these around into estimates for \\(Pr(Y = k|X = x)\\). Linear discriminant analysis (LDA) assumes these distributions are normal.\nBroadly, LDA finds a linear combination of features that characterizes or separates two or more classes of objects or events.\n\nHow does LDA related to other methods?\nLDA is closely related to ANOVA and regression analysis, which also attempt to express one dependent variable as a linear combination of other features or measurements. However, ANOVA uses categorical independent variables and a continuous dependent variable, whereas discriminant analysis has continuous independent variables and a categorical dependent variable (i.e. the class label).\nLogistic regression is more similar to LDA than ANOVA is, as they also explain a categorical variable by the values of continuous independent variables. In fact, logistic regression preferable in applications where it is not reasonable to assume that the distributions of \\(X|Y\\) are normally distributed.\nLDA is also closely related to PCA in that it looks for linear combinations of variables which best explain the data. However, LDA explicitly attempts to model the difference between the classes of data and PCA does not take into account any difference in class. i.e. LDA needs class labels, but PCA does not.\nLDA works when X are continuous quantities. When dealing with categorical X, the equivalent technique is discriminant correspondence analysis.\n\nWhy do we need another method, when we have logistic regression? There are several reasons:\nWhen the classes are well-separated, the parameter estimates for the logistic regression model are surprisingly unstable. Linear discriminant analysis does not suffer from this problem.\nIf \\(n\\) is small and the distribution of the predictors \\(X\\) is approximately normal in each of the classes, the linear discriminant model is again more stable than the logistic regression model.\nLinear discriminant analysis is popular when we have more than two response classes.\nOk, let’s assume we have \\(K\\) classes (\\(K \\geq2\\)). Let \\(\\pi_k\\) represent the overall or prior probability that a randomly chosen observation comes from the \\(k^{th}\\)class or category of the response variable \\(Y\\).\nLet \\(f_{k}(X) ≡ Pr(X = x|Y = k)\\) denote the density function of \\(X\\) for an observation that comes from the \\(k^{th}\\) class (i.e. \\(f_{k}(x)\\) is relatively large if there is a high probability that an observation in the \\(k^{th}\\) class has \\(X \\approx x\\), and \\(f_{k}(x)\\) is small if it is very unlikely. Then Bayes’ theorem states that\n\\[ \\mbox{Pr}(Y=k|X=x) = \\frac{\\mbox{Pr}(Y=k)  Pr(X = x|Y = k)}{\\sum_{l=1}^K \\mbox{Pr}(Y=l) Pr(X = x|Y = l)} = \\frac{\\pi_k f_{k}(x)}{\\sum_{l=1}^K \\pi_l f_{l}(x)} \\]\nSo instead of directly computing \\(\\mbox{Pr}(Y=1|X=x)\\) (i.e. if \\(K=2\\)) in logistic regression, we can plug in estimates for \\(\\pi_k\\) and \\(f_{k}(x)\\).\nTo do this, we make some assumptions about the distributions of \\(f_{k}(x)\\), namely that they are multivariate normal. LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class-specific mean vector and a covariance matrix that is common to all \\(K\\) classes. In our case we have two predictors (\\(X_1\\) and \\(X_2\\)), so we assume each one is bivariate normal. This implies we need to estimate two averages, one standard deviation, and a correlation for each case \\(Y=1\\) and \\(Y=0\\).\nThis implies that we can approximate the distributions \\(f_{0}(X_1, X_2)\\) and \\(f_{1}(X_1, X_2)\\). We can easily estimate parameters from the data:\n\n\noptions(digits = 2)\ntrain_set %>% group_by(y) %>% \n  summarize(avg_1 = mean(X_1), \n            avg_2 = mean(X_2))\n\n\n# A tibble: 2 × 3\n      y  avg_1 avg_2\n  <dbl>  <dbl> <dbl>\n1     0 0.303  0.174\n2     1 0.0418 0.377\n\ntrain_set %>% \n  summarize(sd = sd(X_2), \n            r = cor(X_1,X_2))\n\n\n# A tibble: 1 × 2\n     sd      r\n  <dbl>  <dbl>\n1 0.211 -0.575\n\nSo here are the data and contour plots showing the two normal densities:\n\n\ntrain_set %>% mutate(y = factor(y)) %>% \n  ggplot(aes(X_1, X_2, fill = y, color=y)) + \n  geom_point(pch=21, cex=5, color=\"black\") + \n  stat_ellipse(lwd=2, type=\"norm\") \n\n\n\n\nWe use the lda() function in the MASS R package. The prior argument represents the prior probability of class membership.\n\n\nfit_lda <- MASS::lda(y ~ ., \n                     data=dplyr::select(train_set, y, X_1, X_2),\n                     prior = c(1,1)/2)\npred_lda <- MASS:::predict.lda(fit_lda, test_set)$class\n\n\n\n\n\ntab <- table(pred=pred_lda, truth= test_set$y)\nconf_matrix <- confusionMatrix(tab)\nconf_matrix$table\n\n\n    truth\npred   0   1\n   0 425  41\n   1  75 459\n\nconf_matrix$overall[\"Accuracy\"]\n\n\nAccuracy \n    0.88 \n\nQuadratic discriminant analysis\nAs we have discussed, LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class-specific mean vector and a covariance matrix that is common to all \\(K\\) classes.\nQuadratic discriminant analysis (QDA) assumes that the observations from each class are again drawn from a Gaussian distribution and you plug in estimates for the parameters into Bayes’ theorem in order to perform prediction.\nHowever, unlike LDA, QDA assumes that each class has its own covariance matrix. That is, it assumes that an observation from the \\(k^{th}\\) class is of the form \\(X \\sim N(\\mu_k,\\Sigma_k)\\), where \\(\\Sigma_k\\) is a covariance matrix for the kth class.\nIn our case, we have two predictors (\\(X_1\\) and \\(X_2\\)), so we assume each one is bivariate normal. This implies we need to estimate two averages, two standard deviations, and a correlation for each case \\(Y=1\\) and \\(Y=0\\).\nThis implies that we can approximate the distributions \\(f_{0}(X_1, X_2)\\) and \\(f_{1}(X_1, X_2)\\). We can easily estimate parameters from the data:\n\n\noptions(digits = 2)\nparams <- train_set %>% group_by(y) %>% \n  summarize(avg_1 = mean(X_1), avg_2 = mean(X_2), \n            sd_1= sd(X_1), sd_2 = sd(X_2), \n            r = cor(X_1,X_2))\nparams\n\n\n# A tibble: 2 × 6\n      y  avg_1 avg_2   sd_1  sd_2      r\n  <dbl>  <dbl> <dbl>  <dbl> <dbl>  <dbl>\n1     0 0.303  0.174 0.166  0.143 -0.599\n2     1 0.0418 0.377 0.0946 0.219 -0.234\n\nSo here are the data and contour plots showing the two normal densities:\n\n\ntrain_set %>% mutate(y = factor(y)) %>% \n  ggplot(aes(X_1, X_2, fill = y, color=y)) + \n  geom_point(pch=21,cex=5, color=\"black\") + \n  stat_ellipse(lwd=2, type=\"norm\")\n\n\n\n\nWe can use the qda() function in the MASS R package. The prior argument represents the prior probability of class membership.\n\n\nfit_qda <- MASS::qda(y ~ ., \n                     data=select(train_set, y, X_1, X_2),\n                     prior = c(1,1)/2)\npred_qda <- MASS:::predict.qda(fit_qda, test_set)$class\n\n\n\n\n\ntab <- table(pred=pred_qda, truth= test_set$y)\nconf_matrix <- confusionMatrix(tab)\nconf_matrix$table\n\n\n    truth\npred   0   1\n   0 438  47\n   1  62 453\n\nconf_matrix$overall[\"Accuracy\"]\n\n\nAccuracy \n    0.89 \n\n\nWhy does it matter if we assume a common covariance matrix?\nIn other words, why would one prefer LDA to QDA, or vice-versa?\nThe answer is the bias-variance trade-off. When there are \\(p\\) predictors, then estimating a covariance matrix requires estimating \\(p(p+1)/2\\) parameters. QDA estimates a separate covariance matrix for each class, for a total of \\(Kp(p+1)/2\\) parameters. With 50 predictors this is some multiple of 1,225, which is a lot of parameters. By instead assuming that the \\(K\\) classes share a common covariance matrix, the LDA model estimates \\(Kp\\) linear coefficients.\nConsequently, LDA is a much less flexible classifier than QDA, and so has substantially lower variance. This can potentially lead to improved prediction performance. But there is a trade-off: if LDA’s assumption that the \\(K\\) classes share a common covariance matrix is badly off, then LDA can suffer from high bias.\nRoughly speaking, LDA tends to be a better bet than QDA if there are relatively few training observations and so reducing variance is crucial. In contrast, QDA is recommended if the training set is very large, so that the variance of the classifier is not a major concern, or if the assumption of a common covariance matrix for the \\(K\\) classes is clearly untenable.\n\n\\(K\\)-nearest neighbors\nA model free alternative is the \\(K\\)-nearest neighbor classifier (KNN). Given a positive integer \\(K\\) and a test observation \\(x_0\\), the KNN classifier first identifies the \\(K\\) points in the training data that are closest to \\(x_0\\), represented by \\(N_0\\). It then estimates the conditional probability for class \\(k\\) as the fraction of points in \\(N_0\\) whose response values equal \\(k\\):\n\\[\\mbox{Pr}( Y = k | \\mathbf{X} =\\mathbf{x}_0)  = \\frac{P(Y = k, \\mathbf{X} = \\mathbf{x}_0)}{P(\\mathbf{X} = \\mathbf{x}_0)} = \\frac{1}{K} \\sum_{i \\in N_0} I(y_i = k)\\]\nFinally, KNN applies Bayes rule and classifies the test observation \\(x_0\\) to the class with the largest probability.\nDespite the fact that it is a very simple approach, KNN can often produce classifiers that are surprisingly close to the optimal Bayes classifier.\n\n\nfit_knn_2 <- knn3(y~., \n                  data = select(train_set, y, X_1, X_2), \n                  k=2)\npred_knn_2 <- predict(fit_knn_2, newdata = test_set)[,2]\n\ntab <- table(pred=round(pred_knn_2), truth= test_set$y)\nconf_matrix <- confusionMatrix(tab)\nconf_matrix$table\n\n\n    truth\npred   0   1\n   0 462  79\n   1  38 421\n\nconf_matrix$overall[\"Accuracy\"]\n\n\nAccuracy \n    0.88 \n\nNote: The choice of \\(K\\) has a drastic effect on the KNN classifier obtained. You can explore this own your own by trying \\(K\\) = 1 vs a larger \\(K\\).\n\n\n\n",
    "preview": "posts/2021-11-10-linear-classification/../../images/pants.jpg",
    "last_modified": "2021-11-09T23:11:16-05:00",
    "input_file": {}
  }
]
